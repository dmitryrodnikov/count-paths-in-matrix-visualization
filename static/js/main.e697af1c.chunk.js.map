{"version":3,"sources":["grid/cell.module.css","code.tsx","grid/cell.tsx","grid/row.tsx","grid/grid.tsx","radio-switch/radio-switch.tsx","App.tsx","calculate-paths.ts","index.tsx","radio-switch/radio-switch.module.css"],"names":["module","exports","Code","language","style","lioshi","Cell","rowIndex","colIndex","onClick","isSelected","isMemoized","isWall","paths","useMemo","background","color","borderColor","className","styles","cell","Row","children","display","Grid","grid","onCellClick","selected","map","row","memoized","RadioSwitch","values","onChange","useState","setSelected","container","index","label","value","cn","item","createGrid","width","height","generateWalls","h","w","isStart","isFinish","push","Math","random","gridSize","createInitialGrid","initial","speedSettings","App","amount","setAmount","memory","setMemory","iterations","setIterations","speed","setSpeed","setGrid","isRunning","setRunning","isDone","setDone","timer","useRef","generator","toggleWall","useCallback","newGrid","clearResults","clearStatus","onStep","rowNum","colNum","isMemo","handlePause","current","window","clearInterval","handleResume","res","next","setInterval","done","clearGrid","gridP","stepCallback","step","memo","length","Object","keys","pathsBottom","pathsRight","undefined","calculateAllPaths","prevIterations","href","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.e697af1c.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"cell\":\"cell_cell__3BxHb\"};","import SyntaxHighlighter from 'react-syntax-highlighter';\nimport { lioshi } from 'react-syntax-highlighter/dist/esm/styles/hljs';\n\nconst code = `\n    // \"1\" represents wall\n    const exampleMatrix = [\n        [0, 1, 0],\n        [0, 0, 1],\n        [1, 0, 0], \n    ];\n    \n    function calculateAllPaths(matrix) {\n    const memo = {};\n\n    function step(row, col) {\n        if (matrix[row][col] === 1) {\n            return 0;\n        }\n\n        if (col === matrix[0].length - 1 && row === matrix.length - 1) {\n            return 1;\n        }\n\n        let pathsBottom = 0;\n        let pathsRight = 0;\n\n        if (memo['' + row + col] !== undefined) {\n            return memo['' + row + col];\n        }\n\n        if (col < matrix[0].length - 1) {\n            pathsRight = step(row, col + 1);\n        }\n\n        if (row < matrix.length - 1) {\n            pathsBottom = step(row + 1, col);\n        }\n\n        memo['' + row + col] = pathsRight + pathsBottom;\n\n        return pathsRight + pathsBottom;\n    }\n\n    return step(0, 0);\n}`;\n\nexport const Code = () => {\n    return (\n        <SyntaxHighlighter language=\"javascript\" style={lioshi}>\n            {code}\n        </SyntaxHighlighter>\n    );\n};\n","import React, { useMemo } from 'react';\n\nimport styles from './cell.module.css';\n\ninterface CellProps {\n    isSelected: boolean;\n    isMemoized: boolean;\n    isWall: boolean;\n    paths: number;\n    rowIndex: number;\n    colIndex: number;\n    onClick: (rowIndex: number, colIndex: number) => void;\n}\n\nexport const Cell = ({ rowIndex, colIndex, onClick, isSelected, isMemoized, isWall, paths }: CellProps) => {\n    const handleClick = () => {\n        onClick(rowIndex, colIndex);\n    };\n\n    const { background, color, borderColor } = useMemo<{\n        background?: string;\n        color?: string;\n        borderColor?: string;\n    }>(() => {\n        if (isWall) {\n            return { background: '#113344' };\n        }\n\n        if (isSelected) {\n            return { background: '#ff6600' };\n        }\n\n        if (isMemoized) {\n            return paths > 0 ? { background: '#40916c' } : { background: '#b9cdc4' };\n        }\n\n        return {\n            color: '#666',\n            borderColor: '#cecece',\n        };\n    }, [isWall, isSelected, isMemoized, paths]);\n\n    return (\n        <div\n            className={styles.cell}\n            style={{\n                background,\n                color,\n                borderColor: borderColor || background,\n            }}\n            onClick={handleClick}\n        >\n            {(!isWall && paths) || '-'}\n        </div>\n    );\n};\n","import React from 'react';\n\nexport const Row: React.FC = ({ children }) => {\n    return <div style={{ display: 'flex' }}>{children}</div>;\n};\n","import React from 'react';\nimport { binaryGrid } from '../calculate-paths';\nimport { Cell } from './cell';\nimport { Row } from './row';\n\ninterface GridProps {\n    grid: binaryGrid;\n    selected: [number, number];\n    onCellClick: (rowIndex: number, colIndex: number) => void;\n}\n\nexport const Grid = ({ grid, onCellClick, selected }: GridProps) => {\n    return (\n        <div>\n            {grid.map((row, rowIndex) => {\n                return (\n                    <Row key={rowIndex}>\n                        {row.map((cell, colIndex) => {\n                            return (\n                                <Cell\n                                    key={colIndex}\n                                    onClick={onCellClick}\n                                    rowIndex={rowIndex}\n                                    colIndex={colIndex}\n                                    isWall={cell.isWall}\n                                    isMemoized={cell.memoized || false}\n                                    isSelected={selected[0] === rowIndex && selected[1] === colIndex}\n                                    paths={cell.paths}\n                                />\n                            );\n                        })}\n                    </Row>\n                );\n            })}\n        </div>\n    );\n};\n","import React, { useState } from 'react';\nimport styles from './radio-switch.module.css';\n\nimport cn from 'classnames';\n\ninterface RadioSwitchProps<T> {\n    values: { label: string; value: T }[];\n    onChange: (value: T) => void;\n}\n\nexport const RadioSwitch = <T,>({ values, onChange }: RadioSwitchProps<T>) => {\n    const [selected, setSelected] = useState(0);\n\n    return (\n        <div className={styles.container}>\n            {values.map(({ label, value }, index) => {\n                return (\n                    <button\n                        key={index}\n                        className={cn(styles.item, index === selected && styles.selected)}\n                        onClick={() => {\n                            setSelected(index);\n                            onChange(value);\n                        }}\n                    >\n                        {label}\n                    </button>\n                );\n            })}\n        </div>\n    );\n};\n","import React, { useCallback, useRef, useState } from 'react';\nimport { binaryGrid, calculateAllPaths, StepHandler } from './calculate-paths';\nimport { Code } from './code';\nimport { Grid } from './grid/grid';\nimport { RadioSwitch } from './radio-switch/radio-switch';\nimport './App.css';\n\nconst createGrid = (width: number, height: number, generateWalls: boolean): binaryGrid => {\n    const grid = [];\n\n    for (let h = 0; h < height; h++) {\n        const row: { isWall: boolean; paths: number }[] = [];\n\n        for (let w = 0; w < width; w++) {\n            const isStart = h + w === 0;\n            const isFinish = h === height - 1 && w === width - 1;\n            row.push({\n                isWall: generateWalls ? !isStart && !isFinish && Math.random() > 0.8 : false,\n                paths: 0,\n            });\n        }\n\n        grid.push(row);\n    }\n\n    return grid;\n};\n\n/*\n * todo legend for colors of cell\n */\n\nconst gridSize: [number, number] = [15, 10];\nconst createInitialGrid = (generateWalls: boolean) => createGrid(...gridSize, generateWalls);\nconst initial = createInitialGrid(true);\n\nconst speedSettings = [\n    { value: 30, label: 'Fast' },\n    { value: 100, label: 'Medium' },\n    { value: 300, label: 'Slow' },\n];\n\nfunction App() {\n    // Results\n    const [amount, setAmount] = useState<number>(0);\n    const [memory, setMemory] = useState<number>(0);\n    const [iterations, setIterations] = useState<number>(0);\n    // Settings\n    const [speed, setSpeed] = useState<number>(speedSettings[0].value);\n    const [grid, setGrid] = useState<binaryGrid>(initial);\n    // Status\n    const [isRunning, setRunning] = useState<boolean>(false);\n    const [isDone, setDone] = useState<boolean>(true);\n    const [selected, setSelected] = useState<[number, number]>([0, 0]);\n\n    const timer = useRef<number | null>(null);\n    const generator = useRef<Generator | null>(null);\n\n    const toggleWall = useCallback(\n        (rowIndex: number, colIndex: number) => {\n            const newGrid = [...grid];\n            newGrid[rowIndex][colIndex].isWall = !newGrid[rowIndex][colIndex].isWall;\n            setGrid(newGrid);\n        },\n        [grid],\n    );\n\n    const clearResults = () => {\n        setAmount(0);\n        setMemory(0);\n        setIterations(0);\n    };\n\n    const clearStatus = () => {\n        setRunning(false);\n        setDone(true);\n        setSelected([0, 0]);\n    };\n\n    const onStep: StepHandler = ({ grid, rowNum, colNum, amount, isMemo, memory }) => {\n        grid[colNum][rowNum].paths = amount;\n\n        if (isMemo) {\n            grid[colNum][rowNum].memoized = true;\n        }\n        // why grid updates without explicit setGrid here?\n        setMemory(memory);\n        setSelected([colNum, rowNum]);\n        setGrid(grid);\n    };\n\n    const getClearGrid = () => {\n        return grid.map(row => {\n            return row.map(cell => {\n                return {\n                    ...cell,\n                    paths: 0,\n                    memoized: false,\n                };\n            });\n        });\n    };\n\n    const handleReset = () => {\n        clearResults();\n        clearStatus();\n        setGrid(createInitialGrid(false));\n\n        if (timer.current) {\n            window.clearInterval(timer.current);\n        }\n    };\n\n    const handleGenerateWalls = () => {\n        clearResults();\n        clearStatus();\n        setGrid(createInitialGrid(true));\n\n        if (timer.current) {\n            window.clearInterval(timer.current);\n        }\n    };\n\n    const handleStart = () => {\n        const clearGrid = getClearGrid();\n        setGrid(clearGrid);\n        generator.current = calculateAllPaths(clearGrid, onStep, () => {\n            setIterations(prevIterations => prevIterations + 1);\n        });\n\n        setRunning(true);\n        setDone(false);\n        let res = generator.current.next();\n\n        timer.current = window.setInterval(() => {\n            if (res.done) {\n                setAmount(res.value);\n                setRunning(false);\n                setDone(true);\n                if (timer.current) {\n                    window.clearInterval(timer.current);\n                }\n            }\n            res = generator.current ? generator.current.next() : { done: true, value: null };\n        }, speed);\n    };\n\n    const handlePause = useCallback(() => {\n        if (timer.current) {\n            setRunning(false);\n            window.clearInterval(timer.current);\n        }\n    }, []);\n\n    const handleResume = (speed: number) => {\n        setRunning(true);\n        setDone(false);\n\n        let res = generator.current?.next();\n\n        timer.current = window.setInterval(() => {\n            if (res?.done) {\n                setAmount(res.value);\n                setRunning(false);\n                setDone(true);\n                if (timer.current) {\n                    window.clearInterval(timer.current);\n                }\n            }\n            res = generator.current ? generator.current.next() : { done: true, value: null };\n        }, speed);\n    };\n\n    const handleSpeedChange = (value: number) => {\n        setSpeed(value);\n        if (isRunning) {\n            handlePause();\n            handleResume(value);\n        }\n    };\n\n    return (\n        <div className=\"root\">\n            <h1>Count all possible paths from TOP LEFT to BOTTOM RIGHT corner of matrix</h1>\n            <div className=\"description\">\n                You can only step <b>right</b> and <b>bottom</b>. Avoid walls (black cells).\n            </div>\n            <h2>Visualization</h2>\n            <div className=\"controls\">\n                <button\n                    className=\"button primary\"\n                    onClick={isRunning ? handlePause : isDone ? handleStart : () => handleResume(speed)}\n                    style={{ width: 100 }}\n                >\n                    {isRunning ? 'Pause' : isDone ? 'Start' : 'Resume'}\n                </button>\n                <button className=\"button secondary\" onClick={handleGenerateWalls}>\n                    Generate walls\n                </button>\n                <button className=\"button secondary\" onClick={handleReset}>\n                    Clear walls\n                </button>\n                <RadioSwitch values={speedSettings} onChange={handleSpeedChange} />\n            </div>\n            <Grid grid={grid} onCellClick={toggleWall} selected={selected} />\n            <div className=\"results\">\n                <div className=\"result\">Result: {amount}</div>\n                <div className=\"info\">Memoized: {memory}</div>\n                <div className=\"info\"> Iterations: {iterations}</div>\n            </div>\n            <h2>Solution. Recursion with memoization</h2>\n            <Code />\n            <a href=\"https://github.com/dmitryrodnikov/count-paths-in-matrix-visualization\">View source on GitHub</a>\n        </div>\n    );\n}\n\nexport default App;\n","export type binaryGrid = {\n    isWall: boolean;\n    paths: number;\n    memoized?: boolean;\n}[][];\n\nexport type StepHandler = (props: {\n    grid: binaryGrid;\n    rowNum: number;\n    colNum: number;\n    amount: number;\n    isMemo: boolean;\n    memory: number;\n}) => void;\n\nexport function calculateAllPaths(gridP: binaryGrid, stepCallback: StepHandler, onStep: VoidFunction) {\n    const grid = [...gridP];\n    const memo: Record<string, number> = {};\n\n    function* step(rowNum: number, colNum: number): Generator {\n        if (grid[colNum][rowNum].isWall) {\n            return 0;\n        }\n\n        onStep();\n        // End of path\n        if (rowNum === grid[0].length - 1 && colNum === grid.length - 1) {\n            yield stepCallback({\n                grid,\n                rowNum,\n                colNum,\n                amount: 1,\n                isMemo: false,\n                memory: Object.keys(memo).length,\n            });\n            return 1;\n        }\n\n        let pathsBottom = 0;\n        let pathsRight = 0;\n\n        yield stepCallback({\n            grid,\n            rowNum,\n            colNum,\n            amount: 0,\n            isMemo: false,\n            memory: Object.keys(memo).length,\n        });\n\n        // get value from memory\n        if (memo[`${rowNum}${colNum}`] !== undefined) {\n            yield stepCallback({\n                grid,\n                rowNum,\n                colNum,\n                amount: memo[`${rowNum}${colNum}`],\n                isMemo: false,\n                memory: Object.keys(memo).length,\n            });\n\n            return memo[`${rowNum}${colNum}`];\n        }\n\n        // Make right step\n        if (rowNum < grid[0].length - 1) {\n            // @ts-ignore\n            pathsRight = yield* step(rowNum + 1, colNum);\n        }\n\n        // Make left step\n        if (colNum < grid.length - 1) {\n            // @ts-ignore\n            pathsBottom = yield* step(rowNum, colNum + 1);\n        }\n\n        yield stepCallback({\n            grid,\n            rowNum,\n            colNum,\n            amount: pathsRight + pathsBottom,\n            isMemo: true,\n            memory: Object.keys(memo).length,\n        });\n\n        // After both steps done sum number of underlying paths (for every sub call)\n        memo[`${rowNum}${colNum}`] = pathsRight + pathsBottom;\n\n        // Return that sum to parent call\n        return pathsRight + pathsBottom;\n    }\n\n    return step(0, 0);\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n    <React.StrictMode>\n        <App />\n    </React.StrictMode>,\n    document.getElementById('root'),\n);\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"radio-switch_container__3nwWF\",\"item\":\"radio-switch_item__W9OzG\",\"selected\":\"radio-switch_selected__1iHOd\"};"],"sourceRoot":""}